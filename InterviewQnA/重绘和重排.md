<!-- 重绘和重排.md -->

###浏览器如何获取数据
1. 当我们在地址栏输入url时，浏览器进程的**UI线程**会捕捉到输入的网址，并启动一个网络线程。（否则就会使用默认的搜索引擎对关键字进行查询）
2. 通过**网络线程**，判断是否有重定向，有就直接重定向。判断是否能从App-cache缓存获取，有就直接取缓存。
3. 网络线程请求DNS进行域名解析，从而和服务区建立TCP连接，发出请求并获取响应。

###获取数据后发生什么
1. 检查：网络线程获取到网站数据后，会启用SafeBrowsing（谷歌的站点安全系统）来检查网站安全性。
2. UI新建渲染器：网站数据通过安全校验后，会从网络线程转到UI线程，UI线程会新建一个**渲染器线程**来渲染页面，数据通过IPC从UI线程传输到渲染器线程。
3. 正式进入渲染流程：渲染器线程把接收到的网站数据（html/css/js/img)转换为用户界面

###渲染流程--主线程
1. DOM Tree过程：HTML -> Tokeniser -> Tree Construction-> DOM，先将HTML进行令牌化（获取标签令牌），根据标签构建DOM树（这个过程中img资源不会阻塞DOM树的构建，但是script会立即执行，因为你不知道脚本会不会改变页面HTML的结构）。
2. CSSOM Tree过程：解析CSS文件，构建CSSOM Tree并确定每个CSS节点的计算样式，和DOM Tree过程同时进行。
3. style过程：将两者结合成Render Tree，合并得出DOM的结构和每个节点的对应样式。
4. Layout Tree过程（重排）：将节点放到页面上。计算节点的坐标和该节点需要占用多大的区域。主线程通过遍历DOM和CSSOM来生成Layout Tree，Layout Tree上的每个节点都记录了x、y坐标和边框尺寸。
	> 注：DOM Tree和Layout Tree不是一一对应的，如display:none就不会显示在Layout Tree，而伪类只存在在Layout Tree。Layout Tree和展示在屏幕上的节点是一一对应的。
5. Paint绘制过程（重绘）/Layer Tree过程：
	1) 确认层级顺序：为了确保在屏幕上展示正确的层级，主线程先遍历Layout Tree并创建一个Paint Record绘制记录表（记录了绘制的顺序）。
	2) 生成图层树：将Layout Tree的信息转化Layer Tree。通过对Layer Tree进行Rastering栅格化生成页面上的像素点，Chrome新的方案叫Compositing合成，像PS一样多个图层拼合加载。

接着主线程将这些层级顺序和图层树Layer Tree的信息传递给**合成器线程**进行合成。

###渲染流程--合成器线程/栅格线程/浏览器线程
1. 图块Tiles：合成器线程想对每个图层栅格化，为了充分调动多个线程，会把图层切割成多个小块（图块Tiles），再将每个图块传递给**栅格线程**
2. 存于GPU内存：栅格线程将这些图块栅格化完成之后，会将图块存于GPU的内存，并给合成器线程返回一些绘制块（Draw Quads，标记了图块在GPU内存的位置和图块在页面中的坐标）。
3. 合成器帧：根据Draw Quads，合成器线程生成了合成器帧Frame，该合成器帧通过IPC(Inter-Process Communication)发送给**浏览器线程**
4. 浏览器渲染：浏览器线程只需将合成器帧传送到GPU，GPU渲染合成器帧后就能在页面中显示内容啦！每次页面发生变动，都会产生新的合成器帧，再次渲染到页面上。

###主线程优化
因为DOM->style->layout->paint->layer这个渲染过程跟JS代码同是在主线程中执行的，当有一个不断导致重排重绘的动画效果时，浏览器就需要在每一帧都运行样式计算、布局和绘制的操作，如果运行JS代码会导致卡帧显示不连贯。

> 页面以每秒60帧（16ms每帧）的速率进行时才不会让用户感觉到卡顿。在每一帧中，主线程会先执行style-layout-paint，然后再执行JS代码。如果JS代码执行还没结束就进入下一帧，该帧就无法进行style-layout-paint从而导致卡顿。

因此我们可以采用以下优化方法：
1. 使用requestAnimationFrame()，该API把JS的执行切割，平均分配到每一帧重排重绘结束后且下一帧还没开始之间的空隙执行（实际上是在下一帧开始的时候把暂停JS的执行，归还主线程），因此在下一帧开始前主线程就可以正常地排列和绘制
2. 使用CSS3中的transform动画属性进行动画制作，因为transform属性实现的动画使用的是合成器线程和栅格线程，并不需要进行样式计算、布局和绘制，不会抢占主线程，且使用了GPU运算。因此性能会更好且不掉帧，推荐使用。